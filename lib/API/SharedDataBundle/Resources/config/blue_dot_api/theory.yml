configuration:

    sql_import: imports/theory.yml

    simple:
        select:
            find_theory_by_name:
                sql: find_theory_by_name
                parameters: [name, lesson_id]
            find_all_theories_by_lesson:
                sql: find_all_theories_by_lesson
                parameters: [lesson_id]
            find_theory_by_id:
                sql: find_theory_by_id
                parameters: [id]
            find_decks_by_theory:
                sql: find_decks_by_theory
                parameters: [theory_id]
            find_deck_by_internal_name:
                sql: find_deck_by_internal_name
                parameters: [theory_id, internal_name]
            find_deck_by_id:
                sql: find_deck_by_id
                parameters: [deck_id]

            find_sound_by_filename:
                sql: find_sound_by_filename
                parameters: [file_name]
            find_sounds_by_deck:
                sql: find_sounds_by_deck
                parameters: [deck_id]



        insert:
            create_theory:
                sql: create_theory
                parameters: [name, lesson_id]
            create_theory_deck:
                sql: create_theory_deck
                parameters: [theory_id, internal_name, deck_data, internal_description, show_on_page, ordering]
            create_sound:
                sql: create_sound
                parameters: [relative_path, absolute_path, file_name, absolute_full_path, relative_full_path]
            create_deck_sound:
                sql: create_deck_sound
                parameters: [sound_id, theory_id, deck_id]

        update:
            rename_theory:
                sql: rename_theory
                parameters: [name, theory_id]
            update_theory_deck:
                sql: rename_theory_deck
                parameters: [deck_id, internal_name, deck_data, internal_description, show_on_page, ordering]


    scenario:
        create_theory_deck:
            atomic: true
            statements:
                create_sound:
                    sql: scenario.create_theory_deck.create_sound
                    parameters: [relative_path, absolute_path, file_name, absolute_full_path, relative_full_path, client_original_name]
                create_theory_deck:
                    sql: scenario.create_theory_deck.create_theory_deck
                    parameters: [theory_id, internal_name, deck_data, internal_description, show_on_page, ordering]
                create_deck_sound:
                    sql: scenario.create_theory_deck.create_deck_sound
                    if_exists: create_sound
                    foreign_key:
                        statement_name: create_sound
                        bind_to: sound_id
                    use:
                        statement_name: select_inserted_deck
                        values: {select_inserted_deck.id: deck_id, select_inserted_deck.theory_id: theory_id }
                select_inserted_deck:
                    sql: scenario.create_theory_deck.select_inserted_deck
                    foreign_key:
                        statement_name: create_theory_deck
                        bind_to: deck_id

        update_theory_deck:
            atomic: true
            return_data: ['select_deck.id as deck_id', 'select_sounds.absolute_full_path as files_to_delete']
            statements:
                select_sounds:
                    sql: scenario.update_theory_deck.select_sounds
                    parameters: [deck_id]
                remove_deck_sounds:
                    sql: scenario.update_theory_deck.remove_deck_sounds
                    parameters: [deck_id]
                remove_theory_sounds:
                    sql: scenario.update_theory_deck.remove_theory_sounds
                    parameters: [deck_id]
                update_theory_deck:
                    sql: scenario.update_theory_deck.update_theory_deck
                    parameters: [deck_id, internal_name, deck_data, internal_description, show_on_page, ordering]
                create_sounds:
                    sql: scenario.update_theory_deck.create_sounds
                    parameters: [relative_path, absolute_path, file_name, absolute_full_path, relative_full_path, client_original_name]
                create_deck_sound:
                    sql: scenario.update_theory_deck.create_deck_sound
                    if_exists: create_sounds
                    foreign_key:
                        statement_name: create_sounds
                        bind_to: sound_id
                    use:
                        statement_name: select_deck
                        values: {select_deck.id: deck_id, select_deck.theory_id: theory_id }
                select_deck:
                    sql: scenario.update_theory_deck.select_deck
                    parameters: [deck_id]