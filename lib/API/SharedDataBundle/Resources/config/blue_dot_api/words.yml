configuration:

    sql_import: imports/words.yml

    simple:
        select:
            find_word_image_by_filename:
                sql: "SELECT * FROM word_images WHERE file_name = :file_name"
                parameters: [file_name]

    scenario:
        create_word:
            atomic: true
            statements:
                find_working_language:
                    sql: "SELECT language_id FROM user_working_languages WHERE user_id = :user_id AND working_language = 1"
                    parameters: [user_id]
                create_word:
                    sql: "INSERT INTO words (language_id, word, type) VALUES (:language_id, :word, :type)"
                    parameters: [word, type]
                    use:
                        statement_name: find_working_language
                        values: { find_working_language.language_id: language_id }
                create_image:
                    sql: "INSERT INTO word_images (word_id, relative_path, absolute_path, file_name, absolute_full_path, relative_full_path, original_name) VALUES (:word_id, :relative_path, :absolute_path, :file_name, :absolute_full_path, :relative_full_path, :original_name)"
                    parameters: [relative_path, absolute_path, file_name, absolute_full_path, relative_full_path, original_name]
                    foreign_key:
                        statement_name: create_word
                        bind_to: word_id
                create_word_categories:
                    sql: "INSERT INTO word_category (word_id, category_id) VALUES (:word_id, :category_id)"
                    parameters: [category_id]
                    foreign_key:
                        statement_name: create_word
                        bind_to: word_id
                create_translations:
                    sql: "INSERT INTO translations (word_id, translation) VALUES (:word_id, :translation)"
                    parameters: [translation]
                    foreign_key:
                        statement_name: create_word
                        bind_to: word_id
        # word index scenario group
        find_words_complex:
            atomic: true
            return_data: [select_all_words]
            statements:
                find_working_language:
                    sql: "SELECT language_id FROM user_working_languages WHERE user_id = :user_id AND working_language = 1"
                    parameters: [user_id]
                select_all_words:
                    sql: "SELECT w.*, c.category, t.translation FROM words AS w INNER JOIN categories AS c INNER JOIN word_category AS wc INNER JOIN translations AS t ON w.id = wc.word_id AND wc.category_id = c.id AND t.word_id = w.id AND w.language_id = :language_id"
                    use:
                        statement_name: find_working_language
                        values: { find_working_language.language_id: language_id }

        find_single_word_complex:
            atomic: true
            return_data: [select_word]
            statements:
                find_working_language:
                    sql: "SELECT language_id FROM user_working_languages WHERE user_id = :user_id AND working_language = 1"
                    parameters: [user_id]
                select_word:
                    sql: "SELECT wi.relative_full_path, wi.original_name, w.id, w.word, w.type, wc.category_id AS category, t.translation FROM words AS w INNER JOIN word_category AS wc INNER JOIN translations AS t INNER JOIN word_images AS wi ON w.id = wc.word_id AND t.word_id = w.id AND w.language_id = :language_id AND wi.word_id = w.id WHERE w.id = :word_id"
                    parameters: [word_id]
                    use:
                        statement_name: find_working_language
                        values: { find_working_language.language_id: language_id }

        find_words_simple:
            atomic: true
            statements:
                find_working_language:
                    sql: "SELECT language_id FROM user_working_languages WHERE user_id = :user_id AND working_language = 1"
                    parameters: [user_id]
                select_all_words:
                    sql: "SELECT * FROM words WHERE language_id = :language_id"
                    use:
                        statement_name: find_working_language
                        values: { find_working_language.language_id: language_id }

    callable:
        find_single_word_complex:
            type: object
            name: AdminBundle\BlueDotCallable\SingleWordComplexCallable
        find_words_complex:
            type: object
            name: AdminBundle\BlueDotCallable\WordListCallable
